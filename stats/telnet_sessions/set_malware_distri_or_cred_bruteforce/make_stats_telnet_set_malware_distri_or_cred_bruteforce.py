#!/usr/bin/env python3.5
# -*-coding:UTF-8 -*

'''
# Compute all the necessary data to perform stats
# concerning IP distributing malware or bruteforcing credentials
'''

import sys
import argparse
import redis
import operator
import math
import json
import struct, socket
from datetime import datetime
from datetime import timedelta
import csv
from pprint import pprint
import ast
from statistics import mean, median, pstdev, pvariance


# CONFIG #
dataset = "blackhole27"
fetch_command = ['tftp', 'wget', 'curl', 'nc']
WINDOW_MAX = 168 #168h = 7days
END_OF_DATASET = '20170228'
START_OF_DATASET = '20161128'

# REDIS #
serv_ipSet = redis.StrictRedis(
    host='localhost',
    port=6501,
    db=3)
serv_timestamp = redis.StrictRedis(
    host='localhost',
    port=6501,
    db=2)

def extract_login_and_cmds(Rsess, Bsess):
    expected_user = Rsess[0]
    expected_pass = Rsess[1]
    flag_pass = False
    flag_user = False
    flag_num = 0
    user_black = ""

    pot_cmds = []
    all_cmds = []
    for item in Bsess:
        if len(item) < 1:
            continue
        if 'Password: 'in item:
            flag_pass = True
            flag_num += 1
            #can't check on pswd because not echoed
        if 'Username: ' in item:
            flag_user = True
            flag_num += 1
            user_black = item.split('Username: ')[1]
            user_black = user_black
        if item[0] == '>':
            pot_cmds += [item[1:]]

    #cred
    if not (flag_pass and flag_user):
        cred = (None, None)
        if len(pot_cmds) == 0:
            return cred, [x for x in Rsess[flag_num:]]
        else:
            #not a valid session
            return (None, None), None

    username = ""
    password = None

    if expected_user == user_black:
        username = user_black
        password = expected_pass
    else:
        username = user_black

    #cmds
    for cmd in pot_cmds:
        if cmd in Rsess:
            if cmd == '\r' or cmd == '':
                pass
            else:
                cmd = cmd.strip('\r')
            all_cmds += [cmd]
        else:
            pass
    for unk in Rsess[:3]:
        if (unk not in pot_cmds) and (unk != user_black) and password is None:
            password = unk

    username = username.strip('\r')
    username = "(none)".encode('utf8') if username == "" else username.encode('utf8')
    password = "(none)".encode('utf8') if (password == "" or password is None or password == "\r") else password.strip('\r').encode('utf8')
    cred = (username, password)
    return cred, all_cmds

def format6h(timestamp):
    thedatetime = datetime.fromtimestamp(float(timestamp))
    year = thedatetime.year
    month = thedatetime.month
    day = thedatetime.day
    hour = thedatetime.hour

    #get which part of the they it is
    day_pos = int(hour / 6)

    to_ret = str(year) + str(month).zfill(2) + str(day).zfill(2) + "_"+ str(day_pos)
    return to_ret

def format24h(timestamp):
    thedatetime = datetime.fromtimestamp(float(timestamp))
    year = thedatetime.year
    month = thedatetime.month
    day = thedatetime.day

    to_ret = str(year) + str(month).zfill(2) + str(day).zfill(2)
    return to_ret

def addXday(date_str, num):
    Xdays = timedelta(days=num)
    thedatetime = datetime(int(date_str[0:4]), int(date_str[4:6]), int(date_str[6:8]))
    incremented_date = thedatetime + Xdays
    year = incremented_date.year
    month = incremented_date.month
    day = incremented_date.day

    to_ret = str(year) + str(month).zfill(2) + str(day).zfill(2)
    return to_ret


def put_in_redis():
    print("Computing Stats")

    invalid_session = 0
    #cred -> occ
    dic_set_ip_brute = {}
    dic_set_ip_distri = {}

    iter_num = 0
    all_sessions = serv_timestamp.keys('??????????.?????????')
    tot_sess_num = len(all_sessions)

    for timestamp in all_sessions:
        if(iter_num % int(tot_sess_num/100) == 0):
            print("progress: {}%".format(int(iter_num/tot_sess_num*100)), sep=' ', end='\r', flush=True)
        iter_num += 1


        command_after_log = []
        for session in serv_timestamp.smembers(timestamp):
            session = ast.literal_eval(session.decode('utf-8'))
            ip_remote = session['ip_remote']
            ip_blackhole = session['ip_blackhole']
            session_remote = session['session_remote']
            session_blackhole = session['session_blackhole']
            
            #ranking
            array_remote = session_remote.split('\n')
            array_blackhole = session_blackhole.split('\n')

            #not enough command to complete a login
            if len(array_remote) < 2:
                continue
            cred, cmds = extract_login_and_cmds(array_remote, array_blackhole)
            if cred == (None, None):
                invalid_session += 1
                continue
            else: #session contain credentials
                timeFormat = format6h(timestamp)
                timeFormatDay = format24h(timestamp)
                serv_ipSet.sadd(ip_remote, "bruteforce_"+timeFormat)
                serv_ipSet.zincrby("bruteforce_"+timeFormat, ip_remote)
                serv_ipSet.sadd("setIP_bruteforce_"+timeFormatDay, ip_remote)
                try:
                    dic_set_ip_brute[ip_remote].add(timeFormat)
                except KeyError:
                    dic_set_ip_brute[ip_remote] = set(timeFormat)
            
            #Check for fetch command
            flag_addded = False #consider only one occurence even if multiple matching commands
            for com in fetch_command:
                for individual_command in cmds:
                    if flag_addded:
                        break
                
                    if individual_command.find(com) > -1:#found one matching
                        serv_ipSet.sadd(ip_remote, "distri_"+timeFormat)
                        serv_ipSet.zincrby("distri_"+timeFormat, ip_remote)
                        serv_ipSet.sadd("setIP_distri_"+timeFormatDay, ip_remote)
                        try:
                            dic_set_ip_distri[ip_remote].add(str(timeFormat))
                        except KeyError:
                            dic_set_ip_distri[ip_remote] = set()
                            dic_set_ip_distri[ip_remote].add(str(timeFormat))
                        flag_addded=True
                        break

    print("Sorting dicos")
    sorted_dic_brute = sorted(dic_set_ip_brute.items(), key=operator.itemgetter(0), reverse=False)
    sorted_dic_distri = sorted(dic_set_ip_distri.items(), key=operator.itemgetter(0), reverse=False)
    to_write = { 'dic_set_ip_brute': str(sorted_dic_brute),
            'dic_set_ip_distri': str(sorted_dic_distri),
            'tot_number_of_session': tot_sess_num, 
            'invalid_session': invalid_session}


def is_present_in_window(timestamp, window, ip):
    ONEday = timedelta(days=1)
    parsed = timestamp.split('_')
    set_type = parsed[0]
    date = parsed[1]
    date = datetime(int(date[:4]), int(date[4:6]), int(date[6:8]))
    win_pos = parsed[2]

    #for i in range(6, window+1, 6):
    num_of_window_to_prospect = int(window / 6)

    cur_win_pos = int(win_pos) + 1
    cur_date = date
    for i in range(num_of_window_to_prospect):
        if cur_win_pos == 4:
            cur_date += ONEday
            cur_win_pos = 0

        key = set_type + "_" + \
            str(cur_date.year) + str(cur_date.month) + str(cur_date.day) + "_" \
            + str(cur_win_pos)

        if serv_ipSet.sismember(ip, key):
            return True
        cur_win_pos += 1
    return False

def generate_window_name(timestamp, window_array):
    ONEday = timedelta(days=1)
    parsed = timestamp.split('_')
    set_type = parsed[0]
    date = parsed[1]
    date = datetime(int(date[:4]), int(date[4:6]), int(date[6:8]))
    win_pos = parsed[2]


    num_of_window_to_prospect = len(window_array)
    cur_date = date
    cur_win_pos = int(win_pos) + 1
    windows = []
    window_value = 0
    for i in range(num_of_window_to_prospect):
        if cur_win_pos == 4:
            cur_date += ONEday
            cur_win_pos = 0

        window_value += 6
        key = set_type + "_" + \
            str(cur_date.year) + str(cur_date.month) + str(cur_date.day) + "_" \
            + str(cur_win_pos)
        windows.append((window_value, key))
        cur_win_pos += 1
    return windows


def make_stat(window_size):
    print('Creating datastructure')

    dico_brute = {}
    dico_distri = {}

    #create dic representing:   ip -> timestamp_list
    iter_num = 0
    all_ip = serv_ipSet.keys("*.*.*")
    for ip in all_ip:
        ip = ip.decode('utf8')
        if(iter_num % int(len(all_ip)/100) == 0):
            print("progress: {}%".format(int(iter_num/len(all_ip)*100)), sep=' ', end='\r', flush=True)
        iter_num += 1

        for timestamp in serv_ipSet.sscan_iter(ip):
            timestamp = timestamp.decode('utf8')
            temp = {0: True}
            flag_present = False
            for window, window_key in generate_window_name(timestamp, window_size):
                #Do not check outside of the dataset
                if window_key == END_OF_DATASET+"_0":
                    break
                    
                if serv_ipSet.sismember(ip, window_key) or flag_present:
                    temp[window] = True
                    flag_present = True
                else:
                    temp[window] = False

            if "bruteforce" in timestamp:
                try:
                    dico_brute[ip].append(temp)
                except KeyError:
                    dico_brute[ip] = [temp]

            else:
                try:
                    dico_distri[ip].append(temp)
                except KeyError:
                    dico_distri[ip] = [temp]

    #make the avg of the windows
    dico_distri_avg = {}
    for ip, list_occ in dico_distri.items():
        sum_dico = {}
        #sum values
        for ip_occ in list_occ:
            for window_size, present in ip_occ.items():
                if present:
                    try:
                        sum_dico[int(window_size)] += 1
                    except KeyError:
                        sum_dico[int(window_size)] = 1

        dico_distri_avg[ip] = sum_dico

    dico_brute_avg = {}
    for ip, list_occ in dico_brute.items():
        sum_dico = {}
        #sum values
        for ip_occ in list_occ:
            for window_size, present in ip_occ.items():
                if present:
                    try:
                        sum_dico[int(window_size)] += 1
                    except KeyError:
                        sum_dico[int(window_size)] = 1

        dico_brute_avg[ip] = sum_dico
                    


    '''Windows repartition'''
    print('Computing windows repartition')

    repart_window_distri = {}
    repart_window_distri_uniq = {}
    repart_window_brute = {}
    repart_window_brute_uniq = {}

    tot_distri_ip = 0
    tot_brute_ip = 0
    val_tot_distri_ip = 0
    val_tot_brute_ip = 0
    repart_window_distri = {}
    for ip, window_occ in dico_distri_avg.items():
        tot_distri_ip += 1
        for window_size, occ in window_occ.items():
            val_tot_distri_ip += occ
            if occ >= 1:
                try:
                    repart_window_distri[int(window_size)] += occ
                    repart_window_distri_uniq[int(window_size)] += 1
                except KeyError:
                    repart_window_distri[int(window_size)] = occ
                    repart_window_distri_uniq[int(window_size)] = 1

    repart_window_brute = {}
    for ip, window_occ in dico_brute_avg.items():
        tot_brute_ip += 1
        for window_size, occ in window_occ.items():
            if window_size == 0:
                val_tot_brute_ip += occ
            try:
                repart_window_brute[int(window_size)] += occ
                repart_window_brute_uniq[int(window_size)] += 1
            except KeyError:
                repart_window_brute[int(window_size)] = occ
                repart_window_brute_uniq[int(window_size)] = 1

    weighted_repart_window_distri = {}
    for win, val in repart_window_distri.items():
        weighted_repart_window_distri[win] = (val, val / val_tot_distri_ip)
    weighted_repart_window_distri_uniq = {}
    for win, val in repart_window_distri_uniq.items():
        weighted_repart_window_distri_uniq[win] = (val, val / tot_distri_ip)

    weighted_repart_window_brute = {}
    for win, val in repart_window_brute.items():
        weighted_repart_window_brute[win] = (val, val / val_tot_brute_ip)
    weighted_repart_window_brute_uniq = {}
    for win, val in repart_window_brute_uniq.items():
        weighted_repart_window_brute_uniq[win] = (val, val / tot_brute_ip)


    sorted_weighted_distri = sorted(weighted_repart_window_distri.items(), key=operator.itemgetter(0), reverse=False)
    sorted_weighted_distri_uniq = sorted(weighted_repart_window_distri_uniq.items(), key=operator.itemgetter(0), reverse=False)
    sorted_weighted_brute = sorted(weighted_repart_window_brute.items(), key=operator.itemgetter(0), reverse=False)
    sorted_weighted_brute_uniq = sorted(weighted_repart_window_brute_uniq.items(), key=operator.itemgetter(0), reverse=False)

    dico_windows_repartition = { 'sorted_weighted_brute': sorted_weighted_brute,
            'sorted_weighted_brute_uniq': sorted_weighted_brute_uniq,
            'sorted_weighted_distri': sorted_weighted_distri,
            'sorted_weighted_distri_uniq': sorted_weighted_distri_uniq}


    
    '''cdf duration'''
    print('Computing cdf duration')
    #brute
    cdf_brut_val = []
    for elem in sorted_weighted_brute:
        win, tup = elem
        num, _ = tup
        cdf_brut_val.append(num)

    cdf_brut = []
    for i in range(len(cdf_brut_val)):
        if i == 0:
            continue
        elif i == 1:
            cdf_brut.append(cdf_brut_val[i])
        else:
            cdf_brut.append(cdf_brut_val[i] - cdf_brut_val[i-1])

    #brute uniq
    cdf_brut_val_uniq = []
    for elem in sorted_weighted_brute_uniq:
        win, tup = elem
        num, _ = tup
        cdf_brut_val_uniq.append(num)

    cdf_brut_uniq = []
    for i in range(len(cdf_brut_val_uniq)):
        if i == 0:
            continue
        elif i == 1:
            cdf_brut_uniq.append(cdf_brut_val_uniq[i])
        else:
            cdf_brut_uniq.append(cdf_brut_val_uniq[i] - cdf_brut_val_uniq[i-1])

    #distri
    cdf_distri_val = []
    for elem in sorted_weighted_distri:
        win, tup = elem
        num, _ = tup
        cdf_distri_val.append(num)

    cdf_distri = []
    for i in range(len(cdf_distri_val)):
        if i == 0:
            continue
        elif i == 1:
            cdf_distri.append(cdf_distri_val[i])
        else:
            cdf_distri.append(cdf_distri_val[i] - cdf_distri_val[i-1])
    #distri uniq
    cdf_distri_val_uniq = []
    for elem in sorted_weighted_distri_uniq:
        win, tup = elem
        num, _ = tup
        cdf_distri_val_uniq.append(num)

    cdf_distri_uniq = []
    for i in range(len(cdf_distri_val_uniq)):
        if i == 0:
            continue
        elif i == 1:
            cdf_distri_uniq.append(cdf_distri_val_uniq[i])
        else:
            cdf_distri_uniq.append(cdf_distri_val_uniq[i] - cdf_distri_val_uniq[i-1])

    dico_cdf_duration = {
            'cdf_brut': cdf_brut,
            'cdf_brut_uniq': cdf_brut_uniq,
            'cdf_distri': cdf_distri,
            'cdf_distri_uniq': cdf_distri_uniq}


    '''IP Occurence per day position'''
    print('Computing IP Occurence per day posisition')

    #brute
    dico_daypos_brute_uniq = {'0': 0, '1': 0, '2': 0, '3': 0}
    dico_daypos_brute = {'0': 0, '1': 0, '2': 0, '3': 0}
    tot_card_brute_uniq = 0
    tot_card_brute = 0
    all_brute_timestamp = serv_ipSet.keys("bruteforce_*")
    for timestamp in all_brute_timestamp:
        timestamp = timestamp.decode('utf8')
        for ip, occ in serv_ipSet.zrange(timestamp, 0, -1, withscores=True):
            dayPos = timestamp.split('_')[2]

            #sum
            tot_card_brute += occ
            dico_daypos_brute[dayPos] += occ
            #uniq
            tot_card_brute_uniq += 1
            dico_daypos_brute_uniq[dayPos] += 1

    #distri
    dico_daypos_distri_uniq = {'0': 0, '1': 0, '2': 0, '3': 0}
    dico_daypos_distri = {'0': 0, '1': 0, '2': 0, '3': 0}
    tot_card_distri_uniq = 0
    tot_card_distri = 0
    all_distri_timestamp = serv_ipSet.keys("distri_*")
    for timestamp in all_distri_timestamp:
        timestamp = timestamp.decode('utf8')
        for ip, occ in serv_ipSet.zrange(timestamp, 0, -1, withscores=True):
            dayPos = timestamp.split('_')[2]

            #sum
            tot_card_distri += occ
            dico_daypos_distri[dayPos] += occ
            #uniq
            tot_card_distri_uniq += 1
            dico_daypos_distri_uniq[dayPos] += 1

    dico_ip_occ_per_day_pos = {
            'dico_daypos_brute_uniq': dico_daypos_brute_uniq,
            'dico_daypos_distri_uniq': dico_daypos_distri_uniq,
            'dico_daypos_brute': dico_daypos_brute,
            'dico_daypos_distri': dico_daypos_distri}


    '''IP intersection'''
    print('Computing IP intersection')
    #1day, 3days, 1week, 2weeks, 1month
    #1day, 3days, 7days, 14days, 28days
    allwindows = [1, 3, 7 ,14 ,28]
    dic_set_distri = {1: {}, 3: {}, 7: {}, 14: {}, 28: {}}
    dic_set_brute = {1: {}, 3: {}, 7: {}, 14: {}, 28: {}}

    ''' Distri '''
    alldays = serv_ipSet.keys("setIP_distri_*")
    alldays.sort()

    #dic -> {1,3,7,14,28} -- each --> {all_set_of_length_X} --> 
    array_ips = []

    #generate all possible daterange
    cur_date = START_OF_DATASET
    end_date = int(END_OF_DATASET)
    
    while(int(cur_date) < end_date):
        cur_date = addXday(cur_date, 1)
        dic_set_distri[1][cur_date] = set()


    cur_date = START_OF_DATASET
    #add for window size 1
    for setDay in alldays:
        setDay = setDay.decode('utf8')
        date_str = setDay.split('_')[2]

        #fill array_ips for not present date
        while(cur_date != date_str):
            array_ips.append(set())
            cur_date = addXday(cur_date, 1)
        
        temp_set_ips = set()
        for ip in serv_ipSet.smembers(setDay):
            dic_set_distri[1][date_str].add(ip)
            temp_set_ips.add(ip)
        array_ips.append(temp_set_ips)


    #perfom the union
    for windowSize in allwindows[1:]:
        cur_date = START_OF_DATASET
        day_offset = 0
        while int(cur_date) <= int(END_OF_DATASET):
            unionSet = set()
            for day_iter in range(day_offset, day_offset + windowSize):
                #avoid index-out-of-bound
                if day_iter >= len(array_ips):
                    break
                unionSet = unionSet.union(array_ips[day_iter]) #merge set with day_set
            dic_set_distri[windowSize][cur_date] = unionSet

            #update cur_date
            cur_date = addXday(cur_date, windowSize)
            day_offset += windowSize

    ''' brute '''
    alldays = serv_ipSet.keys("setIP_bruteforce_*")
    alldays.sort()

    #dic -> {1,3,7,14,28} -- each --> {all_set_of_length_X} --> 
    array_ips = []

    #generate all possible daterange
    cur_date = START_OF_DATASET
    end_date = int(END_OF_DATASET)
    
    while(int(cur_date) < end_date):
        dic_set_brute[1][cur_date] = set()
        cur_date = addXday(cur_date, 1)


    cur_date = START_OF_DATASET
    #add for window size 1
    for setDay in alldays:
        setDay = setDay.decode('utf8')
        date_str = setDay.split('_')[2]

        #fill array_ips for not present date
        while(cur_date != date_str):
            array_ips.append(set())
            cur_date = addXday(cur_date, 1)
        
        temp_set_ips = set()
        for ip in serv_ipSet.smembers(setDay):
            dic_set_brute[1][date_str].add(ip)
            temp_set_ips.add(ip)
        array_ips.append(temp_set_ips)


    #perfom the union
    for windowSize in allwindows[1:]:
        cur_date = START_OF_DATASET
        day_offset = 0
        while int(cur_date) <= int(END_OF_DATASET):
            unionSet = set()
            for day_iter in range(day_offset, day_offset + windowSize):
                #avoid index-out-of-bound
                if day_iter >= len(array_ips):
                    break
                unionSet = unionSet.union(array_ips[day_iter]) #merge set with day_set
            dic_set_brute[windowSize][cur_date] = unionSet

            #update cur_date
            cur_date = addXday(cur_date, windowSize)
            day_offset += windowSize


    #compute the intersection between sets of same window
    #this whil show if a fix IP contact the blackhole several time and at which rate
    print('  compute the intersection between all sets')
    dic_intersect_distri = {}
    dic_intersect_brute = {}
    for win in allwindows:
        dic_intersect_distri[win] = set()
        dic_intersect_brute[win] = set()

    for window in dic_set_distri:
        intersectSet = None
        for timestamp, ipSet in dic_set_distri[window].items():
            if intersectSet is None:
                intersectSet = ipSet
                continue

            intersectSet = intersectSet.intersection(ipSet)
        dic_intersect_distri[window] = list(intersectSet)

    for window in dic_set_brute:
        intersectSet = None
        for timestamp, ipSet in dic_set_brute[window].items():
            if intersectSet is None:
                intersectSet = ipSet
                continue

            intersectSet = intersectSet.intersection(ipSet)
        dic_intersect_brute[window] = list(intersectSet)

    #compute max len per window
    #sort set with timestamp
    dic_max_len_per_window = {}
    for dic_to_process, dic_to_process_name in [(dic_set_brute, 'dic_max_len_per_window_brute'), (dic_set_distri, 'dic_max_len_per_window_distri')]:
        dic_max_len_per_window_to_process = {}
        for window in dic_to_process:
            max_intersect_card = 0
            max_intersect_range = 0
            max_intersect_endate = None
            max_intersect_set = set()
            sorted_array = []
            for timestamp, ipSet in dic_to_process[window].items():
                sorted_array.append((timestamp, [ipSet]))
            sorted_array.sort(key= lambda x: x[0])

            #test for all intersection
            for interRange_min in range(len(sorted_array)):
                for interRange_max in range(len(sorted_array)-interRange_min, 0, -1):
                    intersectSet = None
                    for tup in sorted_array[interRange_min:(interRange_min+interRange_max)]:
                        timestamp, IPset = tup
                        IPset = IPset[0]
                        if intersectSet == None:
                            intersectSet = IPset
                        
                        intersectSet = intersectSet.intersection(IPset)
                    if len(intersectSet) > 0 and interRange_max > max_intersect_range:
                        max_intersect_set = intersectSet
                        max_intersect_range = interRange_max
                        max_intersect_card = len(intersectSet)
                        max_intersect_endate = timestamp


            tempDate = datetime(int(max_intersect_endate[0:4]), int(max_intersect_endate[4:6]), int(max_intersect_endate[6:8])) - timedelta(days=max_intersect_range*window)
            max_intersect_startdate = str(tempDate.year) + str(tempDate.month).zfill(2) + str(tempDate.day).zfill(2)
            dic_max_len_per_window_to_process[window] = {'max_intersect_range': max_intersect_range*window,
                    'max_intersect_card': max_intersect_card,
                    'max_intersect_set': max_intersect_set,
                    'max_intersect_endate': max_intersect_endate,
                    'max_intersect_startdate': max_intersect_startdate}
        dic_max_len_per_window[dic_to_process_name] = dic_max_len_per_window_to_process


    dico_intersect = {'dic_intersect_distri': str(dic_intersect_distri),
            'dic_intersect_brute': str(dic_intersect_brute),
            'dic_max_len_per_window': str(dic_max_len_per_window)}


    with open('make_stats_telnet_set_malware_distri_or_cred_bruteforce.output', 'w') as f:
        f.write(json.dumps([dico_windows_repartition,
            dico_cdf_duration,
            dico_ip_occ_per_day_pos,
            dico_intersect]))



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Makes stats about the frequency of IP within a acceptation window')
    parser.add_argument('-plot', '--plot', required=False, default=False, help='plot the data')
    args = parser.parse_args()
    
    #put_in_redis()
    window_size = [x for x in range(6, WINDOW_MAX+6, 6)]
    make_stat(window_size)
