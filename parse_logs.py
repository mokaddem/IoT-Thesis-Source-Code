#!/usr/bin/env python3
# -*-coding:UTF-8 -*

'''
This program parse a log file generated by MTPot.
It keeps a list of:
    - opened connection
    - closed connection
    - timed out connection
    - connection that had problem
'''

import redis
import time
import argparse
from datetime import datetime
import json
import os
from pprint import pprint


# CONFIG
timeout_threshold = 60*60 #sec

# GLOBAL VARIABLES #
open_connection = []
dico_connection = {} #keep info of opened connection
closed_connection = []
timeout_connection = []
problem_log = []
ip_mirai_confirmed = []
ip_mirai_confirmed_uniq = {}


def manage_list_of_open_connection_not_closed():
    for ip in open_connection:
        if (ip not in closed_connection) and (ip not in timeout_connection):
            timestamp = dico_connection[ip]
            if timestamp > timeout_threshold:
                timeout_connection.append([ip, "opened at {}, never closed by program".format(timestamp)])


def parse_log(filename):
    number_of_opened_connection = 0
    last_timestamp = 0
    with open(filename, 'r') as f:
        for line in f:
            try:
                #parsed_line = line.split(" [")
                parsed_line = line.split()
                #3 formats possible:
                #time1, time2, loggerName, INFO/DEBUG, Script:line, [ip], text1, text2  
                #time1, time2, loggerName, INFO/DEBUG, Script:line, 'Mirai confirmed IP:' , [ip], text2
                #time1, time2, loggerName, INFO/DEBUG, Script:line, texts++
                if parsed_line[5] == 'Setup' or parsed_line[5] == 'Listening':
                    continue

                #timestamp
                complete_time = (parsed_line[0]+' '+parsed_line[1]).split(',')[0]
                timestamp = datetime.strptime(complete_time, "%Y-%m-%d %H:%M:%S")
                timestamp = int(time.mktime(timestamp.timetuple()))
                last_timestamp = timestamp if timestamp > last_timestamp else last_timestamp

                #ip
                if ('[' in parsed_line[5]) or (']' in parsed_line[5]):
                    ip = parsed_line[5][1:-1]
                    info = " ".join(parsed_line[6:])
                else:
                    ip = parsed_line[8][1:-1]
                    info = " ".join(parsed_line[5:7])   #Mirai': confirmed'
                    info2 = parsed_line[9]              #['attckName']

                if info == "session started":
                    open_connection.append(ip)
                    dico_connection[ip] = timestamp
                    number_of_opened_connection += 1

                elif info == "session ended":
                    if ip not in open_connection:
                        problem_log.append(("Connection ended but not started", line))
                    else:
                        duration = timestamp - dico_connection[ip]
                        closed_connection.append((ip, duration))
                        del dico_connection[ip]
                        open_connection.remove(ip)

                elif info == "session timed out":
                    if ip not in open_connection:
                        problem_log.append(("Connection ended but not started", line))
                    else:
                        duration = timestamp - dico_connection[ip]
                        timeout_connection.append([ip, "opened at {}, duration".format(timestamp, duration)])

                elif info == 'Responding:':
                    pass
                elif 'logon credentials used:' in info:
                    pass
                elif 'executed: ' in info:
                    pass
                elif info == 'Mirai: confirmed':
                    ip_mirai_confirmed.append([ip, timestamp])
                    only_ip = ip.split(':')[0]
                    ip_mirai_confirmed_uniq[only_ip] = timestamp

                else:
                    print('_-*PARSE_PROB*-_'+info)

            except IndexError as e:
                print('error')
                print(line)
                break

    #manage list of open connection
    manage_list_of_open_connection_not_closed()
    return number_of_opened_connection


if __name__ == "__main__":

    # REDIS #
    serv_ip = redis.StrictRedis(
        host='localhost',
        port=6501,
        db=1)

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-f','--filename',
        type=str,
        required=True,
        help='Path to the log to parse')
    parser.add_argument(
        '-o','--output',
        type=str,
        required=False,
        default=None,
        help='filename to output confirmed ip running mirai')
    args = parser.parse_args()

    opened_connection = parse_log(args.filename)

    #print("_---* OPEN *---_")
    print("{}\tconnections was opened".format(opened_connection))
    
    #print("_---* CLOSED *---_")
    print("{}\tconnections was closed".format(len(closed_connection)))
    #pprint(closed_connection)
    
    #print("_---* TIMEOUT *---_")
    print("{}\tconnections was closed due to timeout".format(len(timeout_connection)))
    #pprint(timeout_connection)

    #print("_---* PROBLEM *---_")
    print("{}\tconnections had a problem".format(len(problem_log)))
    #pprint(problem_log)

    #print("_---* MIRAI CONFIRMED *---_")
    print("{}\tconfirmed ip running mirai".format(len(ip_mirai_confirmed)))
    print("{}\tconfirmed unique ip running mirai".format(len(ip_mirai_confirmed_uniq)))
    #pprint(ip_mirai_confirmed)

    if args.output is not None:
        with open(args.output, 'a') as f:
            to_write = ""
            for l in ip_mirai_confirmed:
                to_write += str(l[0]) + " " + str(int(l[1]))+"\n"

            f.write(to_write)
